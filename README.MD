関数名: get_next_line
プロトタイプ: char *get_next_line(int fd)
提出ファイル: get_next_line.c, get_next_line_utils.c, get_next_line.h
パラメータ: fd - 読み取るファイルディスクリプタ
戻り値: 読み取られた行 (正常な動作)
NULL - もう読み取るものがないか、エラーが発生した場合
外部関数: read, malloc, free

---
説明: ファイルディスクリプタから読み取った行を返す関数です。
・get_next_line()関数を繰り返し呼び出すことにより、ファイルディスクリプタが指すテキストファイルを1行ずつ読み取ることができます。
・関数は読み取られた行を返します。もしごく一行も読み取れなかった場合やエラーが発生した場合はNULLを返します。
・ファイルの読み取りだけでなく、標準入力からの読み取りでも正常に動作するようにしてください。
・ファイルの終端に達した場合を除き、返される行には終端の\n文字が含まれることに注意してください。
・get_next_line.hヘッダーファイルには、get_next_line()関数のプロトタイプが少なくとも含まれている必要があります。
・get_next_line_utils.cファイルに必要なすべてのヘルパー関数を追加してください。

＊まずは、static変数とは何かを理解すると良いでしょう。

・get_next_line()内でファイルを読み取る必要があるため、コンパイラ呼び出しにこのオプションを追加してください: -D BUFFER_SIZE=n
これにより、read()のためのバッファサイズが定義されます。
バッファサイズの値は、ピア評価者およびMoulinetteがコードをテストするために変更されます。
通常のフラグに加えて、-D BUFFER_SIZEフラグを使用してこのプロジェクトをコンパイルできる必要があります。デフォルト値は任意に選択できます。
・以下のようにコードをコンパイルします（バッファサイズとして42を使用した例です）:
cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 <files>.c
・前回の呼び出し以降にファイルディスクリプタが指すファイルが変更された場合、read()がまだファイルの終端に達していない限り、get_next_line()の動作は未定義です。
・また、バイナリファイルの読み取り時にget_next_line()の動作は未定義です。ただし、この動作を処理するための論理的な方法を実装することもできます。

BUFFER_SIZEの値が9999の場合でも、1の場合でも、10000000の場合でも、関数は正常に動作しますか？なぜでしょうか？
get_next_line()が呼び出されるたびにできるだけ少ない量を読み取ってください。改行に出くわした場合、現在の行を返す必要があります。
ファイル全体を読み取ってから各行を処理しないでください。

禁止事項:
・このプロジェクトでは、libftを使用することは許可されていません。
・lseek()の使用は禁止されています。
・グローバル変数の使用は禁止されています。